-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package zuramaru
@version 0.1.0.0


-- | Common types for zuramaru
module Maru.Type.SExpr

-- | The format for the code of maru. (This doesn't mean a file path of the
--   code.)
type SourceCode = Text

-- | The format for the token of <tt>MaruParser</tt>
type MaruToken = Token Text

-- | n-ary tree and terms
data SExpr

-- | Appending list and list
Cons :: SExpr -> SExpr -> SExpr

-- | A representation of empty list
Nil :: SExpr

-- | A pattern of the atom for <a>Int</a>
AtomInt :: Int -> SExpr

-- | A pattern of the atom for <a>Bool</a>
AtomBool :: Bool -> SExpr

-- | A pattern of the atom for <a>MaruSymbol</a>
AtomSymbol :: MaruSymbol -> SExpr

-- | <pre>
--   &gt;&gt;&gt; isAtomInt $ AtomInt 10
--   True
--   
--   &gt;&gt;&gt; isAtomInt Nil
--   False
--   
--   &gt;&gt;&gt; isAtomInt $ AtomSymbol ""
--   False
--   </pre>
isAtomInt :: SExpr -> Bool

-- | Extract <a>Int</a> from a term of <a>AtomInt</a>.
--   
--   <pre>
--   &gt;&gt;&gt; unAtomInt $ AtomInt 10
--   Just 10
--   
--   &gt;&gt;&gt; unAtomInt $ AtomSymbol ":D"
--   Nothing
--   
--   &gt;&gt;&gt; unAtomInt $ Cons (AtomInt 10) (AtomInt 20)
--   Nothing
--   </pre>
unAtomInt :: SExpr -> Maybe Int

-- | <pre>
--   &gt;&gt;&gt; isAtomSymbol $ AtomSymbol "x"
--   True
--   
--   &gt;&gt;&gt; isAtomSymbol Nil
--   False
--   
--   &gt;&gt;&gt; isAtomSymbol $ AtomInt 10
--   False
--   </pre>
isAtomSymbol :: SExpr -> Bool

-- | Similar to <a>unAtomInt</a>
unAtomSymbol :: SExpr -> Maybe MaruSymbol

-- | <tt>a</tt> can be represented as <a>SExpr</a>
class SExprLike a

-- | <tt>a</tt> can be converted as <a>SExpr</a>
wrap :: SExprLike a => a -> SExpr

-- | Show <a>SExpr</a> as the human readable syntax. This is the inverse
--   function of the parser, if the format is ignored (e.g. '( + 1 2)` =~
--   '(+ 1 2)').
--   
--   <pre>
--   &gt;&gt;&gt; readable &lt;$&gt; parse "10"
--   Right "10"
--   
--   &gt;&gt;&gt; parse . readable $ AtomInt 10
--   Right (AtomInt 10)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; readable &lt;$&gt; parse "true"
--   Right "true"
--   
--   &gt;&gt;&gt; parse . readable $ AtomBool True
--   Right (AtomBool True)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; readable &lt;$&gt; parse "(+ 1 2)"
--   Right "(+ 1 2)"
--   
--   &gt;&gt;&gt; let result = parse . readable $ Cons (AtomSymbol "+") (Cons (AtomInt 1) (Cons (AtomInt 2) Nil))
--   
--   &gt;&gt;&gt; result == Right (Cons (AtomSymbol "+") (Cons (AtomInt 1) (Cons (AtomInt 2) Nil)))
--   True
--   </pre>
readable :: SExpr -> Text

-- | A symbol of <tt>MaruEnv</tt>, but this is not meaning a symbol of maru
--   side
newtype MaruSymbol
MaruSymbol :: Text -> MaruSymbol
[unMaruSymbol] :: MaruSymbol -> Text

-- | Wrap <a>String</a>. If you want to wrap <a>Text</a>, please use
--   <a>MaruSymbol</a> value constructor instead.
pack :: String -> MaruSymbol

-- | A dual of <a>pack</a>
unpack :: MaruSymbol -> String

-- | A <tt>Prism</tt> accessor.
--   
--   Get <a>Nothing</a> if [<a>SExpr</a>] includes non <a>AtomSymbol</a>.
--   Get all <a>AtomSymbol</a> otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; [AtomSymbol "x", AtomSymbol "y"] ^? asSymbolList
--   Just ["x","y"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [AtomInt 1, AtomSymbol "y"] ^? asSymbolList
--   Nothing
--   </pre>
asSymbolList :: Prism' [SExpr] [MaruSymbol]

-- | Concatenate <a>SExpr</a> by <a>Cons</a>
--   
--   <pre>
--   &gt;&gt;&gt; let xs = [(AtomInt 1), (Cons (Cons (AtomInt 2) (Cons (AtomInt 3) Nil)) Nil)] -- [1, (2 3)]
--   
--   &gt;&gt;&gt; scottEncode xs
--   Cons (AtomInt 1) (Cons (Cons (Cons (AtomInt 2) (Cons (AtomInt 3) Nil)) Nil) Nil)
--   
--   &gt;&gt;&gt; let ys = [AtomInt 1, AtomInt 2, AtomInt 3] -- [1, 2, 3]
--   
--   &gt;&gt;&gt; scottEncode ys
--   Cons (AtomInt 1) (Cons (AtomInt 2) (Cons (AtomInt 3) Nil))
--   
--   &gt;&gt;&gt; let zs = [AtomInt 1, Nil] -- [1, ()]
--   
--   &gt;&gt;&gt; scottEncode zs
--   Cons (AtomInt 1) (Cons Nil Nil)
--   </pre>
scottEncode :: [SExpr] -> SExpr

-- | The inverse function of <a>scottEncode</a>
--   
--   <pre>
--   &gt;&gt;&gt; let xs = Cons (AtomInt 1) (Cons (AtomInt 2) Nil)
--   
--   &gt;&gt;&gt; scottDecode xs
--   [AtomInt 1,AtomInt 2]
--   
--   &gt;&gt;&gt; scottDecode $ Cons (AtomInt 10) Nil
--   [AtomInt 10]
--   
--   &gt;&gt;&gt; scottDecode $ Cons Nil Nil
--   [Nil]
--   </pre>
scottDecode :: SExpr -> [SExpr]
_Cons :: Prism' SExpr (SExpr, SExpr)
_Nil :: Prism' SExpr ()
_AtomInt :: Prism' SExpr Int
_AtomSymbol :: Prism' SExpr MaruSymbol

-- | Shot only the <a>AtomInt</a>s by <a>omap</a>
newtype SExprIntBullet
SExprIntBullet :: SExpr -> SExprIntBullet
[unSExprIntBullet] :: SExprIntBullet -> SExpr

-- | Apply by <a>omap</a> a function to a <a>SExprIntBullet</a> with
--   wrapping and unwrapping
intBullet :: (Int -> Int) -> SExpr -> SExpr
instance GHC.Classes.Eq Maru.Type.SExpr.SExpr
instance GHC.Show.Show Maru.Type.SExpr.SExpr
instance GHC.Classes.Ord Maru.Type.SExpr.MaruSymbol
instance GHC.Classes.Eq Maru.Type.SExpr.MaruSymbol
instance GHC.Base.Monoid Maru.Type.SExpr.MaruSymbol
instance Data.Semigroup.Semigroup Maru.Type.SExpr.MaruSymbol
instance Data.String.IsString Maru.Type.SExpr.MaruSymbol
instance TextShow.Classes.TextShow Maru.Type.SExpr.SExpr
instance Data.MonoTraversable.MonoFunctor Maru.Type.SExpr.SExprIntBullet
instance GHC.Show.Show Maru.Type.SExpr.MaruSymbol
instance TextShow.Classes.TextShow Maru.Type.SExpr.MaruSymbol
instance Maru.Type.SExpr.SExprLike GHC.Types.Int
instance Maru.Type.SExpr.SExprLike Data.Text.Internal.Text


-- | The type for Maru.Parser
module Maru.Type.Parser

-- | A log message of the parsing, for debug
newtype ParseLog
ParseLog :: Text -> ParseLog
[unParseLog] :: ParseLog -> Text
type ParseLogs = Seq ParseLog

-- | A parser for the code of maru
--   
--   NOTE: This <a>MonadState</a> instance is instead of
--   <tt>MonadWriter</tt>, because <a>ParsecT</a> is not the
--   <tt>MonadWriter</tt> instance.
data MaruParser a

-- | Run parser and extract result and logs.
runMaruParser :: MaruParser a -> Text -> (Either ParseErrorResult a, [ParseLog])

-- | Append a log to head of _parseLogs in the parsing
tell' :: ParseLog -> MaruParser ()

-- | The parse result of the failure
type ParseErrorResult = ParseError MaruToken Dec
instance Control.Monad.Fail.MonadFail Maru.Type.Parser.MaruParser
instance Text.Megaparsec.Prim.MonadParsec Text.Megaparsec.Error.Dec Data.Text.Internal.Text Maru.Type.Parser.MaruParser
instance Control.Monad.State.Class.MonadState Maru.Type.Parser.ParseLogs Maru.Type.Parser.MaruParser
instance GHC.Base.MonadPlus Maru.Type.Parser.MaruParser
instance GHC.Base.Alternative Maru.Type.Parser.MaruParser
instance GHC.Base.Monad Maru.Type.Parser.MaruParser
instance GHC.Base.Applicative Maru.Type.Parser.MaruParser
instance GHC.Base.Functor Maru.Type.Parser.MaruParser
instance GHC.Base.Monoid Maru.Type.Parser.ParseLog
instance Data.String.IsString Maru.Type.Parser.ParseLog
instance GHC.Show.Show Maru.Type.Parser.ParseLog


-- | Integrate types of extensible's Effect.
--   
--   <a>MaruMacro</a> is evaluated by <a>MaruEvaluator</a>. <a>MaruFunc</a>
--   is calculated by <a>MaruCalculator</a>.
module Maru.Type.Eval

-- | An effect of <tt>MaruEvaluator</tt>. A possible of the failure.
type Fail = FailKey >: FailValue
type FailKey = "fail"
type FailValue = EitherEff ExceptionCause

-- | <a>Fail</a>'s <a>Associate</a>
type FailAssociation = Associate FailKey FailValue

-- | <a>throwEff</a> for <a>Fail</a>
throwFail :: FailAssociation xs => ExceptionCause -> Eff xs a

-- | Include <a>Maybe</a> to <a>Fail</a> context. If it is Nothing, the
--   whole of `Fail a` to be failed.
includeFail :: FailAssociation xs => ExceptionCause -> Eff xs (Maybe a) -> Eff xs a

-- | Same as <a>includeFail</a>
includeFail' :: FailAssociation xs => Eff xs (Either ExceptionCause a) -> Eff xs a

-- | A log for 簡約s
type SimplificationSteps = [SExpr]

-- | Append numbers to steps
--   
--   <pre>
--   &gt;&gt;&gt; import Maru.Type.SExpr
--   
--   &gt;&gt;&gt; reportSteps [Cons (AtomInt 1) (Cons (AtomInt 2) Nil), Cons (AtomInt 2) Nil]
--   ["1: (1 2)","2: (2)"]
--   </pre>
reportSteps :: SimplificationSteps -> [Text]

-- | An effect of <tt>MaruEvaluator</tt>, for logging simplifications
type SimplifSteps = SimplifStepsKey >: SimplifStepsValue
type SimplifStepsKey = "simplifSteps"
type SimplifStepsValue = WriterEff SimplificationSteps
type SimplifStepsAssociation = Associate SimplifStepsKey SimplifStepsValue

-- | An effect of <tt>MaruEvaluator</tt>. This is a stack for the lexical
--   scope.
type MaruScopes = MaruScopesKey >: MaruScopesValue
type MaruScopesKey = "maruScopes"
type MaruScopesValue = State MaruEnv
type MaruScopesAssociation = Associate MaruScopesKey MaruScopesValue

-- | Insert a variable to the toplevel scope
--   
--   <pre>
--   &gt;&gt;&gt; (_, env, _) &lt;- flip runMaruEvaluator E.initialEnv $ insertGlobalVar "x" (AtomInt 10)
--   
--   &gt;&gt;&gt; lookup "x" env
--   Just (AtomInt 10)
--   </pre>
insertGlobalVar :: MaruScopesAssociation xs => MaruSymbol -> SExpr -> Eff xs ()

-- | Make a scope in the state, with a variable.
--   
--   NOTE: The scope must be created with one or more variables. It keeps
--   any safety.
--   
--   e.g. 1. unintended empty scope is never created 2. high affinity of
--   <a>MaruEnv</a> (<a>NonEmpty</a>) is kept
newScope :: MaruScopesAssociation xs => MaruSymbol -> SExpr -> Eff xs ()

-- | Remove the newest scope (about the newest scope is written in
--   <a>MaruEnv</a>), and Return removed scope
popNewerScope :: MaruScopesAssociation xs => Eff xs MaruScope

-- | The whole of the runtime state. This is <a>NonEmpty</a>, because the
--   global scope is defined with the program startup
--   
--   and
--   
--   'getMaruEnv &gt;&gt;= return . last' is the toplevel (and this is used
--   as global scope). 'getMaruEnv &gt;&gt;= return . head' is the newest
--   scope.
--   
--   ( This means the cons operation makes a new scope, it is not '++ [x]'.
--   Please see <tt>makeScope</tt>. )
type MaruEnv = NonEmpty MaruScope

-- | <a>getEff</a> for <a>MaruScopes</a>
getMaruEnv :: MaruScopesAssociation xs => Eff xs MaruEnv

-- | <a>putEff</a> for <a>MaruScopes</a>
putMaruEnv :: MaruScopesAssociation xs => MaruEnv -> Eff xs ()

-- | <a>modifyEff</a> for <tt>maruScopes</tt>
modifyMaruEnv :: MaruScopesAssociation xs => (MaruEnv -> MaruEnv) -> Eff xs ()

-- | An effect of <tt>MaruEvaluator</tt>, this is same as <a>IO</a> in
--   <a>Eff</a>
type IOEff = IOEffKey >: IOEffValue
type IOEffKey = "ioEff"
type IOEffValue = IO
type IOEffAssociation = Associate IOEffKey IOEffValue

-- | <a>liftEff</a> for <a>IOEff</a>
liftIOEff :: IOEffAssociation xs => IO a -> Eff xs a

-- | A message of <tt>Fail</tt>
type ExceptionCause = Text

-- | A monad for evaluating a maru's program
type MaruEvaluator = Eff '[Fail, MaruScopes, SimplifSteps, IOEff]

-- | Run an evaluation of <tt>MaruEvaluator a</tt>
runMaruEvaluator :: MaruEvaluator a -> MaruEnv -> IO (Either ExceptionCause a, MaruEnv, SimplificationSteps)

-- | Create a symbol of the variable name, it is unique (is not duplicated)
--   in the runtime.
newSymbol :: MaruEvaluator MaruSymbol

-- | The runtime state. This associates the variable name and the value.
type MaruScope = Map MaruSymbol SExpr

-- | A function of maru. This keeps the purity, don't happen effects.
--   
--   Take [<a>SExpr</a>] as arguments, its length is checked by each
--   function. If it is not the expected length, <a>Nothing</a> maybe
--   given.
--   
--   Notice:
--   
--   The function is Haskell's function, is represented by Haskell. The
--   function is not maru's (runtime's) function (cannot be defined in the
--   runtime).
newtype MaruFunc
MaruFunc :: ([SExpr] -> MaruCalculator SExpr) -> MaruFunc
[execFunc] :: MaruFunc -> [SExpr] -> MaruCalculator SExpr

-- | A macro of maru, this means the impure function.
--   
--   Similar to <a>MaruFunc</a>, but this is possibility to update the
--   state of the environment.
newtype MaruMacro
MaruMacro :: (SExpr -> MaruEvaluator SExpr) -> MaruMacro
[execMacro] :: MaruMacro -> SExpr -> MaruEvaluator SExpr

-- | Find a variable from the whole of the runtime environment with a
--   symbol
lookup :: MaruSymbol -> MaruEnv -> Maybe SExpr

-- | Take a variable from <a>MaruScopes</a> effect. If <tt>sym</tt> is not
--   exists, the whole of this <a>Eff</a> to be failed
lookupVar :: forall xs. (FailAssociation xs, MaruScopesAssociation xs) => MaruSymbol -> Eff xs SExpr

-- | This is like <a>Prism</a>'s accessor, but don't return result as
--   <a>Maybe</a>.
--   
--   Similar to 'x <a>&amp;</a> review f' but Nothing is included as a
--   failure of the whole of <a>MaruEvaluator</a>.
--   
--   <a>Typeable</a> for the error message.
(^$) :: (Typeable s, Typeable a) => MaruEvaluator s -> Getting (First a) s a -> MaruEvaluator a

-- | This has effects of the part of <a>MaruEvaluator</a>. Calculate pure
--   functions.
type MaruCalculator = Eff '[Fail]

-- | Extract the pure calculation from <a>MaruCalculator</a>
runMaruCalculator :: MaruCalculator a -> Either ExceptionCause a

-- | Simular to <a>First</a>, but using '<a>Either</a>
--   <a>ExceptionCause</a>' instead of <a>Maybe</a>
newtype First' a
First' :: Either ExceptionCause a -> First' a
[getFirst'] :: First' a -> Either ExceptionCause a

-- | Like a consturctor, but from '<a>Maybe</a> a'. If <a>Nothing</a> is
--   given, return <a>mempty</a>.
first' :: Maybe a -> First' a

-- | Expand the value of the variables, but these are not evaluated.
--   
--   And +, -, *, and / are not expanded (because it is regarded as like
--   the axioms)
--   
--   simply expanding
--   
--   <pre>
--   &gt;&gt;&gt; (sexpr, _, _) &lt;- flip runMaruEvaluator E.initialEnv $ newScope "x" (AtomInt 10) &gt;&gt; expandVars (AtomSymbol "x")
--   
--   &gt;&gt;&gt; sexpr
--   Right (AtomInt 10)
--   </pre>
--   
--   multi variables
--   
--   <pre>
--   &gt;&gt;&gt; (sexpr, _, _) &lt;- flip runMaruEvaluator E.initialEnv $ newScope "x" (AtomInt 10) &gt;&gt; newScope "y" (AtomBool True) &gt;&gt; expandVars (Cons (AtomSymbol "x") (Cons (AtomSymbol "y") Nil))
--   
--   &gt;&gt;&gt; sexpr
--   Right (Cons (AtomInt 10) (Cons (AtomBool True) Nil))
--   </pre>
--   
--   nested expanding
--   
--   <pre>
--   &gt;&gt;&gt; (sexpr, _, _) &lt;- flip runMaruEvaluator E.initialEnv $ newScope "x" (AtomInt 10) &gt;&gt; newScope "y" (AtomSymbol "x") &gt;&gt; expandVars (AtomSymbol "y")
--   
--   &gt;&gt;&gt; sexpr
--   Right (AtomInt 10)
--   </pre>
expandVars :: (MaruScopesAssociation xs, FailAssociation xs) => SExpr -> Eff xs SExpr

-- | Substitute a value to a variable.
--   
--   "x" is substituted by `AtomInt 10` in `Cons (AtomInt 1) (Cons
--   (AtomSymbol "x") Nil)`.
--   
--   <pre>
--   &gt;&gt;&gt; substituteVar "x" (AtomInt 10) $ Cons (AtomInt 1) (Cons (AtomSymbol "x") Nil)
--   Cons (AtomInt 1) (Cons (AtomInt 10) Nil)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; substituteVar "x" (AtomInt 10) $ Cons (AtomSymbol "x") (Cons (AtomSymbol "x") Nil)
--   Cons (AtomInt 10) (Cons (AtomInt 10) Nil)
--   </pre>
substituteVar :: MaruSymbol -> SExpr -> SExpr -> SExpr
instance GHC.Base.Functor Maru.Type.Eval.First'
instance Control.Monad.Fail.MonadFail Maru.Type.Eval.MaruEvaluator
instance Control.Monad.Fail.MonadFail Maru.Type.Eval.MaruCalculator
instance GHC.Base.Monoid (Maru.Type.Eval.First' a)


-- | Re exports modules of the under of Maru.Type
module Maru.Type


-- | Avoid 'GHC stage restriction' of TemplateHaskell. Define <a>DecsQ</a>
--   functions.
module Maru.TH

-- | makeLenses with <tt>A</tt> suffix. e.g. replEnv -&gt; replEnvA
makeLensesA :: Name -> DecsQ


-- | The parsers
module Maru.Parser

-- | Parse code to AST, and show AST and logs
parseTest :: SourceCode -> IO ()

-- | Pretty print result of debugParse
prettyPrint :: (ParseResult, [ParseLog]) -> IO ()
parseErrorPretty :: ParseErrorResult -> String

-- | Parse code to AST without logs
parse :: SourceCode -> ParseResult

-- | Parse code to AST with logs
debugParse :: SourceCode -> (ParseResult, [ParseLog])
type ParseResult = Either ParseErrorResult SExpr


-- | Define functions and macros, these are used in the runtime,
--   
--   also these are through with <a>MaruEnv</a> (it should be
--   <a>initialEnv</a>)
--   
--   These respects clisp's behavior basically.
--   
--   <a>add</a>, <a>sub</a>, <a>times</a>, and <a>div</a> are regarded as
--   axiomly functions.
module Maru.Eval.RuntimeOperation

-- | <pre>
--   &gt;&gt;&gt; runMaruCalculator $ execFunc add [AtomInt 1, AtomInt 2]
--   Right (AtomInt 3)
--   
--   &gt;&gt;&gt; runMaruCalculator $ execFunc add []
--   Right (AtomInt 0)
--   
--   &gt;&gt;&gt; isLeft . runMaruCalculator $ execFunc add [AtomSymbol "xD"]
--   True
--   </pre>
add :: MaruFunc

-- | <pre>
--   &gt;&gt;&gt; runMaruCalculator $ execFunc sub [AtomInt 3, AtomInt 1]
--   Right (AtomInt 2)
--   
--   &gt;&gt;&gt; runMaruCalculator $ execFunc sub [AtomInt 1]
--   Right (AtomInt (-1))
--   
--   &gt;&gt;&gt; isLeft . runMaruCalculator $ execFunc sub []
--   True
--   
--   &gt;&gt;&gt; isLeft . runMaruCalculator $ execFunc sub [AtomSymbol "xD"]
--   True
--   </pre>
sub :: MaruFunc

-- | <pre>
--   &gt;&gt;&gt; runMaruCalculator $ execFunc times [AtomInt 3, AtomInt 3]
--   Right (AtomInt 9)
--   
--   &gt;&gt;&gt; runMaruCalculator $ execFunc times []
--   Right (AtomInt 1)
--   
--   &gt;&gt;&gt; isLeft . runMaruCalculator $ execFunc times [AtomSymbol "xD"]
--   True
--   </pre>
times :: MaruFunc

-- | <pre>
--   &gt;&gt;&gt; runMaruCalculator $ execFunc div [AtomInt 3, AtomInt 3]
--   Right (AtomInt 1)
--   
--   &gt;&gt;&gt; isLeft . runMaruCalculator $ execFunc div []
--   True
--   
--   &gt;&gt;&gt; isLeft . runMaruCalculator $ execFunc div [AtomSymbol "xD"]
--   True
--   
--   &gt;&gt;&gt; isLeft . runMaruCalculator $ execFunc div [AtomInt 0, AtomInt 1]
--   True
--   
--   &gt;&gt;&gt; runMaruCalculator $ execFunc div [AtomInt 10, AtomInt 3]
--   Right (AtomInt 3)
--   
--   &gt;&gt;&gt; runMaruCalculator $ execFunc div [AtomInt 3, AtomInt 5]
--   Right (AtomInt 0)
--   </pre>
div :: MaruFunc


-- | <tt>MaruEvaluator</tt> evaluates <tt>SEexpr</tt>.
module Maru.Eval

-- | An initial value of the runtime. This is the empty.
initialEnv :: MaruEnv

-- | Evaluate a S expression, and happen its side effects.
--   
--   If you don't have a value of <tt>MaruEnv</tt>, you can use
--   <tt>initialEnv</tt>.
--   
--   Return an evaluated result, with new <tt>MaruEnv</tt> (<tt>env</tt> is
--   changed if the evaluation of <tt>SExpr</tt> changes <tt>MaruEnv</tt>).
eval :: MaruEnv -> SExpr -> IO (Either SomeException (SExpr, MaruEnv, SimplificationSteps))
instance GHC.Show.Show a0 => GHC.Show.Show (Maru.Eval.EvalException a0)
instance (Data.Typeable.Internal.Typeable * a0, GHC.Show.Show a0) => GHC.Exception.Exception (Maru.Eval.EvalException a0)

module Maru.Main

-- | Run REPL of zuramaru
runRepl :: IO ()
instance Data.Extensible.Internal.Associate (* -> *) GHC.Types.Symbol "stateRepl" (Control.Monad.Trans.State.Strict.State Maru.Main.ReplState) xs => Control.Monad.State.Class.MonadState Maru.Main.ReplState (Data.Extensible.Effect.Eff GHC.Types.Symbol xs)
instance GHC.Show.Show Maru.Main.DebugLogs
instance Data.Data.Data Maru.Main.CliOptions
instance GHC.Show.Show Maru.Main.CliOptions
